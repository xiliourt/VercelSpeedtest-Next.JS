<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Speed Test (Vercel)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .metric-card {
            background-color: white;
            border-radius: 0.75rem; /* 12px */
            padding: 1.5rem; /* 24px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease-in-out;
        }
        .metric-card h2 {
            color: #1e3a8a; /* Dark blue */
        }
        .metric-card .value {
            color: #1d4ed8; /* Medium blue */
            font-weight: 700;
        }
        .metric-card .unit {
            color: #60a5fa; /* Lighter blue */
        }
        .btn-primary {
            background-color: #2563eb; /* Blue-600 */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #1d4ed8; /* Blue-700 */
        }
        .btn-primary:disabled {
            background-color: #9ca3af; /* Gray-400 */
            cursor: not-allowed;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #e5e7eb; /* Gray-200 */
            border-radius: 0.5rem; /* 8px */
            overflow: hidden;
            height: 10px; /* Slimmer progress bar */
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #3b82f6; /* Blue-500 */
            transition: width 0.5s ease-in-out;
            border-radius: 0.5rem; /* 8px */
        }
        #statusMessage {
            color: #4b5563; /* Gray-600 */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800">Internet Speed Test</h1>
            <p class="text-gray-600 mt-2">Using Vercel serverless backend.</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            <div id="pingCard" class="metric-card text-center">
                <h2 class="text-xl font-semibold mb-2">Ping</h2>
                <p><span id="pingValue" class="value text-4xl">0</span> <span class="unit text-lg">ms</span></p>
            </div>
            <div id="downloadCard" class="metric-card text-center">
                <h2 class="text-xl font-semibold mb-2">Download</h2>
                <p><span id="downloadValue" class="value text-4xl">0.00</span> <span class="unit text-lg">Mbps</span></p>
            </div>
            <div id="uploadCard" class="metric-card text-center">
                <h2 class="text-xl font-semibold mb-2">Upload</h2>
                <p><span id="uploadValue" class="value text-4xl">0.00</span> <span class="unit text-lg">Mbps</span></p>
            </div>
        </div>

        <div class="text-center mb-6">
            <button id="startButton" class="btn-primary font-semibold py-3 px-8 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Start Test
            </button>
        </div>

        <div class="mb-4 px-2">
            <div id="statusMessage" class="text-center text-lg font-medium mb-2 h-6"></div>
            <div class="progress-bar-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>
         <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow max-h-40 overflow-y-auto">
            <h3 class="font-semibold text-gray-700 mb-2">Log:</h3>
            <pre id="logOutput" class="text-xs text-gray-600 whitespace-pre-wrap"></pre>
        </div>
    </div>

    <script>
        const startButton = document.getElementById('startButton');
        const pingValue = document.getElementById('pingValue');
        const downloadValue = document.getElementById('downloadValue');
        const uploadValue = document.getElementById('uploadValue');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const logOutput = document.getElementById('logOutput');

        // --- Configuration (MUST align with backend and test intent) ---
        const PING_COUNT = 5;
        // This is the size the client *expects* the server to send for download.
        // The api/server.js is configured to send this amount.
        const DOWNLOAD_FILE_SIZE_BYTES = 25 * 1024 * 1024; // 25MB

        // This is the size of data the client will generate and attempt to upload.
        // IMPORTANT: For Vercel Hobby plan, this MUST be < 4.5MB (e.g., 4 * 1024 * 1024).
        // The Vercel platform has a request body size limit (e.g., 4.5MB on Hobby).
        // If you use a Pro plan or Vercel Blob, you can use larger sizes.
        const UPLOAD_DATA_SIZE_BYTES = 4 * 1024 * 1024; // 4MB (Example for Vercel Hobby plan)
        // const UPLOAD_DATA_SIZE_BYTES = 10 * 1024 * 1024; // Original 10MB (OK for Pro/custom non-Vercel Hobby servers)
        
        // --- Backend Endpoints ---
        // For Vercel, use relative paths (empty string) so it resolves to the current deployment's domain.
        const SERVER_BASE_URL = ''; 

        function logMessage(message) {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            logOutput.textContent += `[${timestamp}] ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll
        }

        function resetUI() {
            pingValue.textContent = '0';
            downloadValue.textContent = '0.00';
            uploadValue.textContent = '0.00';
            statusMessage.textContent = '';
            progressBar.style.width = '0%';
            logOutput.textContent = '';
            logMessage('UI Reset. Ready for new test with Vercel backend.');
        }

        async function measurePing() {
            logMessage('Starting Ping Test (Vercel Backend)...');
            statusMessage.textContent = 'Testing Ping...';
            progressBar.style.width = '10%';
            let totalPingTime = 0;
            let successfulPings = 0;

            for (let i = 0; i < PING_COUNT; i++) {
                const startTime = performance.now();
                try {
                    // Add a cache-busting parameter to ensure fresh request
                    const pingUrl = `${SERVER_BASE_URL}/ping?iter=${i}&_=${Date.now()}`;
                    const response = await fetch(pingUrl, { method: 'GET', cache: 'no-store' });
                    if (response.ok) {
                        await response.text(); // Ensure full request cycle
                        const endTime = performance.now();
                        totalPingTime += (endTime - startTime);
                        successfulPings++;
                        logMessage(`Ping ${i + 1}/${PING_COUNT}: ${(endTime - startTime).toFixed(2)} ms`);
                    } else {
                        logMessage(`Ping ${i + 1}/${PING_COUNT} failed: HTTP ${response.status} to ${pingUrl}`);
                    }
                } catch (error) {
                    logMessage(`Ping ${i + 1}/${PING_COUNT} error: ${error.message}`);
                }
                // Small delay between pings, except for the last one
                if (i < PING_COUNT - 1) {
                    await new Promise(resolve => setTimeout(resolve, 200)); 
                }
            }

            if (successfulPings > 0) {
                const avgPing = totalPingTime / successfulPings;
                pingValue.textContent = avgPing.toFixed(0);
                logMessage(`Average Ping: ${avgPing.toFixed(0)} ms`);
            } else {
                pingValue.textContent = 'N/A';
                logMessage('Ping test failed.');
            }
            progressBar.style.width = '25%';
        }

        async function measureDownloadSpeed() {
            logMessage('Starting Download Test (Vercel Backend)...');
            statusMessage.textContent = 'Testing Download Speed...';
            progressBar.style.width = '30%';
            const startTime = performance.now();
            let receivedLength = 0;
            const downloadUrl = `${SERVER_BASE_URL}/download?_=${Date.now()}`; // Cache buster

            try {
                const response = await fetch(downloadUrl, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} from ${downloadUrl}`);
                }
                
                const reader = response.body.getReader();
                // eslint-disable-next-line no-constant-condition
                while(true) {
                    const {done, value} = await reader.read();
                    if (done) {
                        break;
                    }
                    receivedLength += value.length;
                    // Update progress bar based on received data
                    // Download phase is from 25% to 70% of the progress bar (45% total span)
                    const downloadProgress = (receivedLength / DOWNLOAD_FILE_SIZE_BYTES) * 45;
                    progressBar.style.width = `${Math.min(25 + downloadProgress, 70)}%`; 
                }

                const endTime = performance.now();
                const durationMs = endTime - startTime;
                const durationSeconds = durationMs / 1000;

                if (durationSeconds > 0 && receivedLength > 0) {
                    const speedMbps = (receivedLength * 8) / durationSeconds / 1000000;
                    downloadValue.textContent = speedMbps.toFixed(2);
                    logMessage(`Download complete. Actual Size: ${(receivedLength / (1024*1024)).toFixed(2)} MB, Expected: ${(DOWNLOAD_FILE_SIZE_BYTES / (1024*1024)).toFixed(2)} MB, Time: ${durationSeconds.toFixed(2)}s, Speed: ${speedMbps.toFixed(2)} Mbps`);
                    if (receivedLength !== DOWNLOAD_FILE_SIZE_BYTES) {
                         logMessage(`Warning: Downloaded size (${receivedLength} bytes) differs from client's expected size (${DOWNLOAD_FILE_SIZE_BYTES} bytes). Speed calculation uses actual downloaded size.`);
                    }
                } else {
                    downloadValue.textContent = 'N/A';
                    logMessage('Download test failed, took 0 time, or received 0 bytes.');
                }
            } catch (error) {
                downloadValue.textContent = 'Error';
                logMessage(`Download test error: ${error.message}`);
                console.error('Download error:', error);
            }
            progressBar.style.width = '70%'; // End of download phase
        }

        async function measureUploadSpeed() {
            logMessage('Starting Upload Test (Vercel Backend)...');
            statusMessage.textContent = 'Testing Upload Speed...';
            progressBar.style.width = '75%';

            // Generate random data for upload.
            // Using a Uint8Array is memory efficient.
            const data = new Uint8Array(UPLOAD_DATA_SIZE_BYTES);
            // For speed test purposes, the content of the data doesn't strictly matter, only its size.
            // Filling it with crypto.getRandomValues is more realistic but can be slow for large arrays.
            // try { crypto.getRandomValues(data); } catch (e) { for(let i=0; i<data.length; i++) data[i] = i % 256; }


            const blob = new Blob([data]);
            const startTime = performance.now();
            const uploadUrl = `${SERVER_BASE_URL}/upload`;

            try {
                const response = await fetch(uploadUrl, {
                    method: 'POST',
                    body: blob,
                    headers: { 
                        'Content-Type': 'application/octet-stream' // Standard for binary data
                    },
                    cache: 'no-store' // Ensure it's not cached
                });

                if (!response.ok) {
                    // Try to get more error info from Vercel if possible
                    let errorBody = '';
                    try {
                        errorBody = await response.text();
                    } catch (e) { /* ignore */ }
                    logMessage(`Upload failed: HTTP ${response.status}. Body: ${errorBody}`);
                    throw new Error(`HTTP error! status: ${response.status} from ${uploadUrl}. Body: ${errorBody}`);
                }
                await response.text(); // Consume response to ensure it's fully processed

                const endTime = performance.now();
                const durationMs = endTime - startTime;
                const durationSeconds = durationMs / 1000;

                if (durationSeconds > 0) {
                    const speedMbps = (UPLOAD_DATA_SIZE_BYTES * 8) / durationSeconds / 1000000;
                    uploadValue.textContent = speedMbps.toFixed(2);
                    logMessage(`Upload complete. Size: ${(UPLOAD_DATA_SIZE_BYTES / (1024*1024)).toFixed(2)} MB, Time: ${durationSeconds.toFixed(2)}s, Speed: ${speedMbps.toFixed(2)} Mbps`);
                } else {
                    uploadValue.textContent = 'N/A';
                    logMessage('Upload test failed or took 0 time.');
                }
            } catch (error) {
                uploadValue.textContent = 'Error';
                logMessage(`Upload test error: ${error.message}`);
                console.error('Upload error:', error);
            }
            progressBar.style.width = '100%';
        }

        async function startTest() {
            resetUI();
            startButton.disabled = true;
            startButton.textContent = 'Testing...';
            logMessage('Speed test initiated (Vercel Backend).');

            try {
                await measurePing();
                await measureDownloadSpeed();
                await measureUploadSpeed(); // Ensure this is called
                statusMessage.textContent = 'Test Complete!';
                logMessage('All tests completed.');
            } catch (error) {
                statusMessage.textContent = 'An error occurred.';
                logMessage(`Critical error during test sequence: ${error.message}`);
                console.error("Test sequence error:", error);
            } finally {
                startButton.disabled = false;
                startButton.textContent = 'Start Test Again';
            }
        }

        startButton.addEventListener('click', startTest);

        // Initial UI state
        logMessage('Speed Test page loaded. Using Vercel backend. Click "Start Test" to begin.');
        if (UPLOAD_DATA_SIZE_BYTES > 4.5 * 1024 * 1024) {
            logMessage(`WARNING: UPLOAD_DATA_SIZE_BYTES (${(UPLOAD_DATA_SIZE_BYTES/(1024*1024)).toFixed(2)}MB) may exceed Vercel Hobby plan limits (4.5MB). Upload test might fail.`);
        }
    </script>

</body>
</html>
